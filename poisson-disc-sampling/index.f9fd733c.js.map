{"mappings":"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","sources":["src/poisson-disc-sampling/index.ts","src/utils.ts"],"sourcesContent":["import { vec2 as Vector2 } from 'gl-matrix';\nimport { run } from '../utils';\n\ntype Grid = [Int32Array, number, number];\nconst createGrid = (xLenght: number, y: number): Grid => {\n    const data = new Int32Array(xLenght * y);\n    return [data, xLenght, y];\n}\nconst setGrid = (x: number, y: number, value: number, grid: Grid): Grid => {\n    const [data, xLenght] = grid;\n    data[x + y * xLenght] = value;\n    return grid;\n}\nconst getGrid = (x: number, y: number, grid: Grid): number => {\n    const [data, xLenght] = grid;\n    return data[x + y * xLenght];\n}\n\nfunction range(start: number, end: number) {\n    return Math.floor(Math.random() * (end - start) + start);\n}\n\nfunction sqrMagniture(a: Vector2, b: Vector2) {\n    return Vector2.sqrDist(a, b);\n}\n\nfunction isValid(\n    candidate: Vector2,\n    sampleRegionSize: Vector2,\n    cellSize: number,\n    radius: number,\n    points: Vector2[],\n    grid: Grid,\n    gridX: number,\n    gridY: number\n) {\n    if (candidate[0] >= 0 && candidate[0] < sampleRegionSize[0] && candidate[1] >= 0 && candidate[1] < sampleRegionSize[1]) {\n        const cellX = Math.floor(candidate[0] / cellSize);\n        const cellY = Math.floor(candidate[1] / cellSize);\n\n        const searchStartX = Math.max(0, cellX - 2);\n        const searchEndX = Math.min(cellX + 2, gridX - 1);\n        const searchStartY = Math.max(0, cellY - 2);\n        const searchEndY = Math.min(cellY + 2, gridY - 1);\n\n        for (let x = searchStartX; x <= searchEndX; x++) {\n            for (let y = searchStartY; y <= searchEndY; y++) {\n                const pointIndex = getGrid(x, y, grid) - 1;\n                if (pointIndex !== -1) {\n                    if (sqrMagniture(candidate, points[pointIndex]) <= (radius * radius)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n\n    }\n    return false;\n}\n\nfunction* generatePoints(radius: number, sampleRegionSize: Vector2, centerPoint: Vector2, numSamplesBeforeRejection: number = 30) {\n    const cellSize = radius / Math.sqrt(2);\n\n    const gridX = Math.ceil(sampleRegionSize[0] / cellSize);\n    const gridY = Math.ceil(sampleRegionSize[1] / cellSize);\n    const grid: Grid = createGrid(gridX, gridY);\n\n    const points: Vector2[] = [];\n    const spawnPoints: Vector2[] = [];\n    spawnPoints.push(centerPoint);\n\n    let dir = Vector2.create();\n    let candidate = Vector2.create();\n    while (spawnPoints.length > 0) {\n        const spawnIndex = range(0, spawnPoints.length);\n        const spawnCenter = spawnPoints[spawnIndex];\n        let candidateAccepted = false;\n        dir = Vector2.create();\n        candidate = Vector2.create();\n        for (let i = 0; i < numSamplesBeforeRejection; i++) {\n            dir = Vector2.random(dir);\n            const factor = range(radius, radius * 2);\n            candidate = Vector2.add(\n                candidate,\n                spawnCenter,\n                Vector2.multiply(dir, dir, Vector2.fromValues(factor, factor))\n            )\n            if (isValid(candidate, sampleRegionSize, cellSize, radius, points, grid, gridX, gridY)) {\n                points.push(candidate);\n                spawnPoints.push(candidate);\n\n                setGrid(Math.floor(candidate[0] / cellSize), Math.floor(candidate[1] / cellSize), points.length, grid);\n                candidateAccepted = true;\n                yield candidate;\n                break;\n            }\n            else {\n                yield null;\n            }\n        }\n        if (!candidateAccepted) {\n            spawnPoints.splice(spawnIndex, 1);\n        }\n    }\n}\n\nfunction drawCicle(ctx: CanvasRenderingContext2D, point: Vector2, radius: number) {\n    ctx.lineWidth = 0;\n    ctx.fillStyle = \"#a85a54\";\n    ctx.beginPath();\n    ctx.arc(point[0], point[1], radius, 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.fill();\n    ctx.fillStyle = \"#FFFFFF\";\n    ctx.beginPath();\n    ctx.arc(point[0], point[1], radius * 0.10, 0, Math.PI * 2);\n    ctx.closePath();\n    ctx.fill();\n}\n\nconst start = () => {\n    const canvas = <HTMLCanvasElement>document.getElementById(\"app\") || document.createElement('canvas');\n\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n\n    const ctx: CanvasRenderingContext2D = canvas.getContext('2d') || new CanvasRenderingContext2D();\n\n    const { width, height } = canvas;\n\n    const radius: number = 10;\n    const vectorOf2 = Vector2.fromValues(2, 2);\n    let regionSize: Vector2 = Vector2.fromValues(width, height);\n    let centerPoint = Vector2.fromValues(regionSize[0] / 2, regionSize[1] / 2);\n    const rejectSamples: number = 30;\n    const displayRadius: number = radius / 2;\n\n    let genPoints = generatePoints(radius, regionSize, centerPoint, rejectSamples);\n    let requestId: number | undefined;\n\n    window.onresize = () => {\n        canvas.width = canvas.clientWidth;\n        canvas.height = canvas.clientHeight;\n\n        regionSize = Vector2.set(regionSize, canvas.width, canvas.height);\n        centerPoint = Vector2.divide(centerPoint, regionSize, vectorOf2);\n        genPoints = generatePoints(radius, regionSize, centerPoint, rejectSamples);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        unsubscribe();\n        unsubscribe = run(update);\n    }\n\n    document.addEventListener('click', (ev: MouseEvent) => {\n        regionSize = Vector2.set(regionSize, canvas.width, canvas.height);\n        centerPoint = Vector2.set(centerPoint, ev.x, ev.y);\n        genPoints = generatePoints(radius, regionSize, centerPoint, rejectSamples)\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        unsubscribe();\n        unsubscribe = run(update);\n    });\n\n    const SIXTY_FRAMES_PER_SECOND = 1000 / 70;\n    let frameCount = 0;\n\n    const update = () => {\n        const start = Date.now();\n        frameCount++;\n        do {\n            const { done, value } = genPoints.next();\n            if (!done && value) drawCicle(ctx, value, displayRadius)\n            if (done) return console.log({\n                frameCount\n            });\n        }\n        while ((Date.now() - start) < SIXTY_FRAMES_PER_SECOND)\n    };\n    let unsubscribe = run(update);\n}\nstart();\n\nexport { };\n","export const run = (update: (time: number) => void) => {\n    const start = performance.now();\n    const frame = (timestamp: number) => {\n        const time = timestamp - start;\n        update(time);\n        requestId = requestAnimationFrame(frame)\n    };\n    let requestId = requestAnimationFrame(frame)\n\n    return () => cancelAnimationFrame(requestId);\n}\n"],"names":["$6yEsn","parcelRequire","$df5bef30413a053b$export$889ea624f2cb2c57","update","start","performance","now","frame","timestamp","requestId","requestAnimationFrame","cancelAnimationFrame","$f9c6031a8205c824$var$setGrid","x","y","value","grid","data","xLenght","$f9c6031a8205c824$var$getGrid","$f9c6031a8205c824$var$range","start1","end","Math","floor","random","$f9c6031a8205c824$var$isValid","candidate","sampleRegionSize","cellSize","radius","points","gridX","gridY","cellX","cellY","searchStartX","max","searchEndX","min","searchStartY","searchEndY","pointIndex","a","b","vec2","sqrDist","$f9c6031a8205c824$var$generatePoints","centerPoint","numSamplesBeforeRejection","sqrt","ceil","Int32Array","spawnPoints","push","dir","create","length","spawnIndex","spawnCenter","candidateAccepted","i","factor","add","multiply","fromValues","splice","$f9c6031a8205c824$var$drawCicle","ctx","point","lineWidth","fillStyle","beginPath","arc","PI","closePath","fill","canvas","document","getElementById","createElement","width","clientWidth","height","clientHeight","getContext","CanvasRenderingContext2D","vectorOf2","regionSize","genPoints","window","onresize","set","divide","clearRect","unsubscribe","addEventListener","ev","frameCount","start2","Date","done","next","console","log","$f9c6031a8205c824$var$start"],"version":3,"file":"index.f9fd733c.js.map"}