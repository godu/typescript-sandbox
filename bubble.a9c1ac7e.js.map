{"version":3,"sources":["webgl/bubble/index.vert","webgl/bubble/index.frag","webgl/utils.ts","utils.ts","webgl/bubble/index.ts"],"names":["module","exports"],"mappings":"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","file":"bubble.a9c1ac7e.js","sourceRoot":"../src","sourcesContent":["module.exports=\"#define GLSLIFY 1\\nattribute vec2 coords;\\nattribute vec4 color;\\nattribute float pointSize;\\nvarying vec4 vColor;\\nvoid main() {\\n    vColor = color;\\n    gl_Position = vec4( coords, 0.0, 1.0 );\\n    gl_PointSize = pointSize;\\n}\\n\";","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\nvarying vec4 vColor;\\nvoid main() {\\n    float dist = distance( vec2(0.5,0.5), gl_PointCoord );\\n    if ( dist > 0.5 ) {\\n       discard;\\n    }\\n    gl_FragColor = vColor;\\n}\\n\";","\n/* Creates a program for use in the WebGL context gl, and returns the\n * identifier for that program.  If an error occurs while compiling or\n * linking the program, an exception of type String is thrown.  The error\n * string contains the compilation or linking error.  If no error occurs,\n * the program identifier is the return value of the function.\n */\nexport function createProgram(gl: WebGLRenderingContext, vertexShaderSource: string, fragmentShaderSource: string) {\n    const vsh = gl.createShader(gl.VERTEX_SHADER);\n    if (vsh === null) throw new TypeError('vsh');\n    gl.shaderSource(vsh, vertexShaderSource);\n    gl.compileShader(vsh);\n    if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {\n        throw new Error(\"Error in vertex shader : \" + gl.getShaderInfoLog(vsh));\n    }\n\n\n    const fsh = gl.createShader(gl.FRAGMENT_SHADER);\n    if (fsh === null) throw new TypeError('fsh');\n    gl.shaderSource(fsh, fragmentShaderSource);\n    gl.compileShader(fsh);\n    if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {\n        throw new Error(\"Error in fragment shader : \" + gl.getShaderInfoLog(fsh));\n    }\n\n    const program = gl.createProgram();\n    if (program === null) throw new TypeError('program');\n    gl.attachShader(program, vsh);\n    gl.attachShader(program, fsh);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error(\"Link error in program:  \" + gl.getProgramInfoLog(program));\n    }\n\n    return program;\n}\n","export const run = (update: (time: number) => void) => {\n    const start = performance.now();\n    const frame = (timestamp: number) => {\n        const time = timestamp - start;\n        update(time);\n        requestId = requestAnimationFrame(frame)\n    };\n    let requestId = requestAnimationFrame(frame)\n\n    return () => cancelAnimationFrame(requestId);\n}\n","import vertexShaderSource from './index.vert';\nimport fragmentShaderSource from './index.frag';\nimport { createProgram } from '../utils';\nimport { run } from '../../utils';\n\nconst canvas = <HTMLCanvasElement>document.getElementById('app');\nif (canvas === null) throw new TypeError('canvas');\nconst gl = canvas.getContext('webgl');\nif (gl === null) throw new TypeError('webgl');\n\ncanvas.width = canvas.clientWidth;\ncanvas.height = canvas.clientHeight;\ngl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);\nwindow.onresize = function () { // reset canvas size when window size is changed\n    canvas.width = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    gl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);\n}\n\nfunction draw(gl: WebGLRenderingContext) {\n    const prog = createProgram(gl, vertexShaderSource, fragmentShaderSource);\n\n    /* Get the locations for shader program variables */\n    const aCoords = gl.getAttribLocation(prog, \"coords\");\n    const aColor = gl.getAttribLocation(prog, \"color\");\n    const aPointSize = gl.getAttribLocation(prog, \"pointSize\");\n\n    /* Create buffers to hold data for the attribute variables. */\n    const aColorBuffer = gl.createBuffer();\n    const aCoordsBuffer = gl.createBuffer();\n    const aPointSizeBuffer = gl.createBuffer();\n\n\n    const POINT_COUNT = 200;\n    const POINTSIZE_MIN = 50;\n    const POINTSIZE_MAX = 255;  // maximum possible value, since I'm using Uint8Array for the point sizes\n    const ALPHA_MIN = 0.2;\n    const ALPHA_MAX = 0.7;\n    const SPEED_MIN = 0.005;\n    const SPEED_MAX = 0.015;\n\n    const coords = new Float32Array(2 * POINT_COUNT);\n    const velocities = new Float32Array(2 * POINT_COUNT);\n    const colors = new Float32Array(4 * POINT_COUNT);\n    const pointSizes = new Uint8Array(POINT_COUNT);\n\n    /* Set up data arrays. */\n    for (let i = 0; i < POINT_COUNT; i++) {\n        pointSizes[i] = Math.round(POINTSIZE_MIN + (POINTSIZE_MAX - POINTSIZE_MIN)*Math.random());\n        coords[2*i] = -1 + 2*Math.random();\n        coords[2*i+1] = -1 + 2*Math.random();\n        const speed = SPEED_MIN + (SPEED_MAX - SPEED_MIN)*Math.random();\n        const angle = 2*Math.PI*Math.random();\n        velocities[2*i] = Math.cos(angle) * speed;\n        velocities[2*i+1] = Math.sin(angle) * speed;\n        colors[4*i] = Math.random();\n        colors[4*i+1] = Math.random();\n        colors[4*i+2] = Math.random();\n        colors[4*i+3] = ALPHA_MIN + (ALPHA_MAX - ALPHA_MIN)*Math.random();\n    }\n\n    /* Load color and point sizes into the buffers; this data doesn't change after initialization. */\n    gl.enableVertexAttribArray(aColor);\n    gl.bindBuffer(gl.ARRAY_BUFFER, aColorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(aPointSize);\n    gl.bindBuffer(gl.ARRAY_BUFFER, aPointSizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, pointSizes, gl.STATIC_DRAW);\n    gl.vertexAttribPointer(aPointSize, 1, gl.UNSIGNED_BYTE, false, 0, 0);\n\n    gl.useProgram(prog);\n\n    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);\n    gl.enable(gl.BLEND);\n\n\n\n    return function (time: number) {\n        for (let i = 0; i < coords.length; i++) {\n            coords[i] += velocities[i]\n            if (coords[i] < -1) {\n                coords[i] = -1;\n                velocities[i] = Math.abs(velocities[i]);\n            }\n            if (coords[i] > 1) {\n                coords[i] = 1;\n                velocities[i] = -Math.abs(velocities[i]);\n            }\n        }\n\n        gl.clearColor(1,1,1,1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        gl.enableVertexAttribArray(aCoords);\n        gl.bindBuffer(gl.ARRAY_BUFFER, aCoordsBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STREAM_DRAW);\n        gl.vertexAttribPointer(aCoords, 2, gl.FLOAT, false, 0, 0);\n\n        gl.drawArrays(gl.POINTS, 0, POINT_COUNT);\n    };\n};\n\nrun(draw(gl))\n"]}